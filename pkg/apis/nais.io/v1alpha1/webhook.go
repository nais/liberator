package nais_io_v1alpha1

import (
	"context"
	"fmt"
	"time"

	aiven_io_v1alpha1 "github.com/nais/liberator/pkg/apis/aiven.io/v1alpha1"
	aiven_nais_io_v1 "github.com/nais/liberator/pkg/apis/aiven.nais.io/v1"
	"github.com/nais/liberator/pkg/webhookvalidator"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/errors"
	"k8s.io/apimachinery/pkg/util/validation"
	"k8s.io/apimachinery/pkg/util/validation/field"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

var _ webhook.CustomValidator = &ApplicationValidator{}

// +kubebuilder:object:generate=false
type ApplicationValidator struct {
	client.Client
}

func SetupWebhookWithManager(mgr ctrl.Manager) error {
	return ctrl.NewWebhookManagedBy(mgr).
		WithValidator(&ApplicationValidator{Client: mgr.GetClient()}).
		For(&Application{}).
		Complete()
}

// The generated manifest is invalid, so we use kubebuilder to make the initial manifest, and then update with annotations and correct name manually
// The default webhook path generated by controller-runtime follows the pattern `/validate-<group>-<version>-<kind>`
// DISABLE: +kubebuilder:webhook:verbs=create;update,path=/validate-nais-io-v1alpha1-application,mutating=false,failurePolicy=fail,groups=nais.io,resources=applications,versions=v1alpha1,name=validation.applications.nais.io

func (v *ApplicationValidator) ValidateCreate(ctx context.Context, obj runtime.Object) (warnings admission.Warnings, err error) {
	a, ok := obj.(*Application)
	if !ok {
		return nil, apierrors.NewBadRequest(fmt.Sprintf("expected an Application but got a %T", obj))
	}

	if len(a.GetName()) > validation.LabelValueMaxLength {
		return nil, apierrors.NewBadRequest(fmt.Sprintf("Application name length must be no more than %d characters", validation.LabelValueMaxLength))
	}

	if a.Spec.TTL != "" {
		if _, err := time.ParseDuration(a.Spec.TTL); err != nil {
			return nil, apierrors.NewBadRequest(fmt.Sprintf("TTL is not a valid duration: %q. Example of valid duration is '12h'", a.Spec.TTL))
		}
	}

	if err := v.checkAivenReferences(ctx, a); err != nil {
		return nil, err
	}

	return nil, nil
}

func (v *ApplicationValidator) ValidateUpdate(ctx context.Context, oldObj runtime.Object, newObj runtime.Object) (warnings admission.Warnings, err error) {
	// Type-cast from runtime.Object to Application
	oldA, ok := oldObj.(*Application)
	if !ok {
		return nil, apierrors.NewBadRequest(fmt.Sprintf("expected an Application but got a %T", oldObj))
	}
	a, ok := newObj.(*Application)
	if !ok {
		return nil, apierrors.NewBadRequest(fmt.Sprintf("expected an Application but got a %T", newObj))
	}

	// Perform actual comparison
	if err := webhookvalidator.NaisCompare(a.Spec, oldA.Spec, field.NewPath("spec")); err != nil {
		if allErrs, ok := err.(errors.Aggregate); ok {
			return nil, apierrors.NewInvalid(
				schema.GroupKind{Group: GroupVersion.Group, Kind: "Application"},
				a.Name,
				fromAggregate(allErrs),
			)
		}

		return nil, err
	}

	if err := v.checkAivenReferences(ctx, a); err != nil {
		return nil, err
	}

	return nil, nil
}

func (v *ApplicationValidator) ValidateDelete(ctx context.Context, obj runtime.Object) (warnings admission.Warnings, err error) {
	return nil, nil
}

func (v *ApplicationValidator) checkAivenReferences(ctx context.Context, app *Application) error {
	if app.Spec.OpenSearch != nil && app.Spec.OpenSearch.Instance != "" {
		fullyQualifiedName := aiven_nais_io_v1.OpenSearchFullyQualifiedName(app.Spec.OpenSearch.Instance, app.Namespace)
		opensearch := &aiven_io_v1alpha1.OpenSearch{}
		if err := v.Get(ctx, client.ObjectKey{Name: fullyQualifiedName, Namespace: app.Namespace}, opensearch); err != nil {
			if apierrors.IsNotFound(err) {
				return apierrors.NewBadRequest(fmt.Sprintf("OpenSearch '%s' does not exist. Create the OpenSearch instance first.", app.Spec.OpenSearch.Instance))
			}
			return apierrors.NewInternalError(fmt.Errorf("could not validate OpenSearch reference: %w", err))
		}
	}

	for _, valkey := range app.Spec.Valkey {
		fullyQualifiedName := aiven_nais_io_v1.ValkeyFullyQualifiedName(valkey.Instance, app.Namespace)
		valkeyObj := &aiven_io_v1alpha1.Valkey{}
		if err := v.Get(ctx, client.ObjectKey{Name: fullyQualifiedName, Namespace: app.Namespace}, valkeyObj); err != nil {
			if apierrors.IsNotFound(err) {
				return apierrors.NewBadRequest(fmt.Sprintf("Valkey '%s' does not exist. Create the Valkey instance first.", valkey.Instance))
			}
			return apierrors.NewInternalError(fmt.Errorf("could not validate Valkey reference: %w", err))
		}
	}
	return nil
}

func fromAggregate(agg errors.Aggregate) field.ErrorList {
	errs := agg.Errors()
	list := make(field.ErrorList, len(errs))
	for i := range errs {
		list[i] = errs[i].(*field.Error)
	}
	return list
}
