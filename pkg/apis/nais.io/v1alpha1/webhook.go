package nais_io_v1alpha1

import (
	"context"
	"fmt"
	"time"

	"github.com/go-logr/logr"
	aiven_io_v1alpha1 "github.com/nais/liberator/pkg/apis/aiven.io/v1alpha1"
	aiven_nais_io_v1 "github.com/nais/liberator/pkg/apis/aiven.nais.io/v1"
	"github.com/nais/liberator/pkg/webhookvalidator"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/errors"
	"k8s.io/apimachinery/pkg/util/validation"
	"k8s.io/apimachinery/pkg/util/validation/field"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/webhook"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

const (
	LabelKillAfter = "euthanaisa.nais.io/kill-after"
)

var _ webhook.CustomValidator = &ApplicationValidator{}
var _ webhook.CustomDefaulter = &ApplicationMutator{}

// +kubebuilder:object:generate=false
type ApplicationValidator struct {
	client.Client
	logger logr.Logger
}

// +kubebuilder:object:generate=false
type ApplicationMutator struct{}

func SetupWebhookWithManager(mgr ctrl.Manager) error {
	return ctrl.NewWebhookManagedBy(mgr).
		WithValidator(&ApplicationValidator{
			Client: mgr.GetClient(),
			logger: mgr.GetLogger().WithName("application-validator"),
		}).
		WithDefaulter(&ApplicationMutator{}).
		For(&Application{}).
		Complete()
}

// The generated manifest is invalid, so we use kubebuilder to make the initial manifest, and then update with annotations and correct name manually
// The default webhook path generated by controller-runtime follows the pattern `/validate-<group>-<version>-<kind>`
// DISABLE: +kubebuilder:webhook:verbs=create;update,path=/validate-nais-io-v1alpha1-application,mutating=false,failurePolicy=fail,groups=nais.io,resources=applications,versions=v1alpha1,name=validation.applications.nais.io

func (v *ApplicationValidator) ValidateCreate(ctx context.Context, obj runtime.Object) (warnings admission.Warnings, err error) {
	a, ok := obj.(*Application)
	if !ok {
		return nil, apierrors.NewBadRequest(fmt.Sprintf("expected an Application but got a %T", obj))
	}

	if len(a.GetName()) > validation.LabelValueMaxLength {
		return nil, apierrors.NewBadRequest(fmt.Sprintf("Application name length must be no more than %d characters", validation.LabelValueMaxLength))
	}

	if a.Spec.TTL != "" {
		if _, err := time.ParseDuration(a.Spec.TTL); err != nil {
			return nil, apierrors.NewBadRequest(fmt.Sprintf("TTL is not a valid duration: %q. Example of valid duration is '12h'", a.Spec.TTL))
		}
	}

	if err := v.checkAivenReferences(ctx, a); err != nil {
		return nil, err
	}

	if err := v.checkPostgresReference(ctx, a); err != nil {
		return nil, err
	}

	return nil, nil
}

func (v *ApplicationValidator) ValidateUpdate(ctx context.Context, oldObj runtime.Object, newObj runtime.Object) (warnings admission.Warnings, err error) {
	// Type-cast from runtime.Object to Application
	oldA, ok := oldObj.(*Application)
	if !ok {
		return nil, apierrors.NewBadRequest(fmt.Sprintf("expected an Application but got a %T", oldObj))
	}
	a, ok := newObj.(*Application)
	if !ok {
		return nil, apierrors.NewBadRequest(fmt.Sprintf("expected an Application but got a %T", newObj))
	}

	// Perform actual comparison
	if err := webhookvalidator.NaisCompare(a.Spec, oldA.Spec, field.NewPath("spec")); err != nil {
		if allErrs, ok := err.(errors.Aggregate); ok {
			return nil, apierrors.NewInvalid(
				schema.GroupKind{Group: GroupVersion.Group, Kind: "Application"},
				a.Name,
				fromAggregate(allErrs),
			)
		}

		return nil, err
	}

	if err := v.checkAivenReferences(ctx, a); err != nil {
		return nil, err
	}

	if err := v.checkPostgresReference(ctx, a); err != nil {
		return nil, err
	}

	return nil, nil
}

func (v *ApplicationValidator) ValidateDelete(ctx context.Context, obj runtime.Object) (warnings admission.Warnings, err error) {
	return nil, nil
}

func (v *ApplicationValidator) checkAivenReferences(ctx context.Context, app *Application) error {
	if app.Spec.OpenSearch != nil && app.Spec.OpenSearch.Instance != "" {
		fullyQualifiedName := aiven_nais_io_v1.OpenSearchFullyQualifiedName(app.Spec.OpenSearch.Instance, app.Namespace)
		opensearch := &aiven_io_v1alpha1.OpenSearch{}
		if err := v.Get(ctx, client.ObjectKey{Name: fullyQualifiedName, Namespace: app.Namespace}, opensearch); err != nil {
			if apierrors.IsNotFound(err) {
				return apierrors.NewBadRequest(fmt.Sprintf("OpenSearch '%s' does not exist. Create the OpenSearch instance first.", app.Spec.OpenSearch.Instance))
			}
			return apierrors.NewInternalError(fmt.Errorf("could not validate OpenSearch reference: %w", err))
		}
	}

	for _, valkey := range app.Spec.Valkey {
		fullyQualifiedName := aiven_nais_io_v1.ValkeyFullyQualifiedName(valkey.Instance, app.Namespace)
		valkeyObj := &aiven_io_v1alpha1.Valkey{}
		if err := v.Get(ctx, client.ObjectKey{Name: fullyQualifiedName, Namespace: app.Namespace}, valkeyObj); err != nil {
			if apierrors.IsNotFound(err) {
				return apierrors.NewBadRequest(fmt.Sprintf("Valkey '%s' does not exist. Create the Valkey instance first.", valkey.Instance))
			}
			return apierrors.NewInternalError(fmt.Errorf("could not validate Valkey reference: %w", err))
		}
	}
	return nil
}

func (v *ApplicationValidator) checkPostgresReference(ctx context.Context, app *Application) error {
	if app.Spec.Postgres != nil && app.Spec.Postgres.ClusterName != "" {
		pgMetaData := &metav1.PartialObjectMetadata{
			TypeMeta: metav1.TypeMeta{
				APIVersion: "data.nais.io/v1",
				Kind:       "Postgres",
			},
		}
		if err := v.Get(ctx, client.ObjectKey{Name: app.Spec.Postgres.ClusterName, Namespace: app.GetNamespace()}, pgMetaData); err != nil {
			if apierrors.IsNotFound(err) {
				v.logger.Info("Rejecting application because the Postgres cluster does not exist",
					"application", app.GetName(),
					"namespace", app.GetNamespace(),
					"postgresCluster", app.Spec.Postgres.ClusterName,
				)
				return apierrors.NewBadRequest(fmt.Sprintf("Postgres '%s' does not exist. Create the Postgres cluster first.", app.Spec.Postgres.ClusterName))
			}
			v.logger.Error(err, "internal error when validating Postgres reference")
			return apierrors.NewInternalError(fmt.Errorf("could not validate Postgres reference: %w", err))
		}
	}
	return nil
}

func fromAggregate(agg errors.Aggregate) field.ErrorList {
	errs := agg.Errors()
	list := make(field.ErrorList, len(errs))
	for i := range errs {
		list[i] = errs[i].(*field.Error)
	}
	return list
}

// Default implements webhook.CustomDefaulter - sets kill-after label if TTL is specified
func (m *ApplicationMutator) Default(ctx context.Context, obj runtime.Object) error {
	app, ok := obj.(*Application)
	if !ok {
		return fmt.Errorf("expected an Application but got a %T", obj)
	}

	if app.Spec.TTL == "" {
		return nil
	}

	d, err := time.ParseDuration(app.Spec.TTL)
	if err != nil {
		return nil // Validation webhook will catch this
	}

	if app.Labels == nil {
		app.Labels = make(map[string]string)
	}
	app.Labels[LabelKillAfter] = time.Now().Add(d).Format(time.RFC3339)
	return nil
}
